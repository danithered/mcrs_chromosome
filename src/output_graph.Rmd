---
title: Report of a simulation
output: 
  html_document:
    toc: true
    toc_float: true
    self_contained: false
params:
  report:
    label: Which report would you like to see?
    input: select
    value: testParDeath4_7_highDeath
    choices: !r list.dirs("/home/danielred/data/programs/mcrs_chromosome/OUT", recursive = F, full.names = F)
  abrmax:
    label: Set maximum of timepoints to plot (add negative value to show them all)
    input: numeric
    value: 9000
  abrmin:
    label: Set minimum of timepoints to plot
    input: numeric
    value: 0
  kompl:
    label: Would you like to output complemeter plots too? (lots of time)
    value: FALSE
  cache.path:
    label: Set path of cache folder
    value: report_cache/
  ssh:
    label: Reach remote host?
    value: FALSE
  ssh_address:
    label: SSH address in format of user@domain:port
    value: ""
  ssh_dir:
    label: rootdir on SSH server
    value: ""
  ssh_key:
    label: Location of ssh public key
    value: ~/.ssh/id_rsa
editor_options: 
  chunk_output_type: console
---

```{r, setup, include=FALSE, message=F}
message("report: ", params$report, 
        "\ncache.path: ", params$cache.path,
        "\nssh: ", params$ssh, 
        "\nssh_address: ", params$ssh_address, 
        "\nssh_dir: ", params$ssh_dir,
        "\nssh_key: ", params$ssh_key )

rootdir="/home/danielred/data/programs/mcrs_chromosome/OUT/"

# set this option in the first code chunk in the document
knitr::opts_chunk$set(echo = F, cache.path=params$cache.path )
message(paste("cache dir:", params$cache.path) )

# libraries
library(RColorBrewer)
library(ggplot2)
library(gganimate)
library(lattice)
library(scales)
library(knitr)
library(Polychrome)
library(cowplot)

par.orig <- par(no.readonly = T) # save default parameters

whattosee <- params$report
workdir <- ifelse(as.logical(params$ssh),
                  paste0(params$ssh_dir, "/", whattosee, "/"),
                  paste0(rootdir, whattosee, "/"))

```


```{r functions, cache=T}
################
## Functions ###
################

plotNeigh <- function(neigh_tipus, 
                      ylim=NA,
                      xlim=NA,
                      asp=NA, 
                      xlab=NA, 
                      ylab=NA, 
                      axes=NA,
                      las=NA,
                      bty=NA,
                      main=NA,
                      ...)
{
  n_inic_x = n_inic_y = c()
  maxDist = ceiling(log2( neigh_tipus - 1))
  for(x  in -maxDist:maxDist){ 
    for(y in -maxDist:maxDist){ 
      if( 2^abs(x) + 2^abs(y) <= neigh_tipus ){
        n_inic_x <- c(n_inic_x, x)
        n_inic_y <- c(n_inic_y, y)
      }
    } 
  }
  
  k <- matrix(rep(0, (maxDist*2+1)^2 ), ncol=maxDist*2+1)
  middle <- maxDist + 1
  
  for(i in 1:length(n_inic_x)){
    k[middle + n_inic_x[i], middle +n_inic_y[i] ] <- 1
  }
  k[middle+0,middle+0] <- 2
  
  #parameters
  if(is.na(ylim)) ylim=c(-maxDist-0.5,maxDist+0.5)
  if(is.na(xlim)) xlim=c(-maxDist-0.5,maxDist+0.5)
  if(is.na(asp)) asp=1
  if(is.na(xlab)) xlab=""
  if(is.na(ylab)) ylab=""
  if(is.na(axes)) {
    axes=F
    draw.axis=T
  } else {
    draw.axis=F
  }
  if(is.na(las)) las=1
  if(is.na(bty)) bty="n"
  if(is.na(main)) main=neigh_tipus
  
  #draw grid
  image(-maxDist:maxDist, -maxDist:maxDist, k, 
        ylim=ylim,
        xlim=xlim,
        asp=asp, 
        xlab=xlab, 
        ylab=ylab, 
        axes=axes,
        las=las,
        bty=bty,
        main=main,
        ...) 
  segments(-(maxDist+1):maxDist+0.5, 
           rep(-maxDist-0.5, maxDist*4 ), 
           -(maxDist+1):maxDist+0.5, 
           rep(maxDist+0.5, maxDist*4 ),
           col="grey")
  segments( y0=-(maxDist+1):maxDist+0.5, 
            x0=rep(-maxDist-0.5, maxDist*4 ), 
            y1=-(maxDist+1):maxDist+0.5,
            x1=rep(maxDist+0.5, maxDist*4 ),
            col="grey")
  #abline(h=-(maxDist+1):maxDist+0.5, col="grey")
  #abline(v=-(maxDist+1):maxDist+0.5, col="grey")
  if(draw.axis){
    axis(1, lwd=0, at=-maxDist:maxDist)
    axis(2, lwd=0, at=-maxDist:maxDist, las=1)
  }
  return( sum(k != 0) )
}

enzN <- Vectorize(function(x){
  if(x==0) return("parazite")
  if(x==-1) return("empty")
  
  m <- ceiling(log(x,2))
  acts <- c()
  
  for(i in m:0){
    if(x %/% 2^i != 0){
      acts <- c(acts, i)
      x <- x-2^i
      if(x == 0) break
    }
  }
  
  return( as.expression(bquote(E[.(paste(sort(acts), collapse = ","))])) )
})

beszur <- function(m, pos, val= 0){
  m2 <- matrix(val,ncol=ncol(m)+1, nrow=nrow(m)+1)
  cn <- colnames(m)
  rn <- rownames(m)
  
  if(pos > 1){
    m2[1:(pos-1), 1:(pos-1)] <- m[1:(pos-1), 1:(pos-1)]
  }
  if(pos <= ncol(m)){
    m2[(pos+1):(ncol(m)+1),(pos+1):(ncol(m)+1)] <- m[pos:ncol(m),pos:ncol(m)]
    if(pos > 1){
      m2[pos:ncol(m)+1,1:(pos-1)] <- m[pos:ncol(m),1:(pos-1)]
      m2[1:(pos-1),pos:ncol(m)+1] <- m[1:(pos-1),pos:ncol(m)]
    }
  }
  
  if( !is.null(cn) ) {
    if(pos == 1){ # elejere
      ncn <- c(NA, cn)
      nrn <- c(NA, rn)
    } else if(pos > ncol(m)){ #vegere
      ncn <- c(cn, NA)
      nrn <- c(rn, NA)
    } else{ # koztes
      ncn <- c(cn[1:(pos-1)], NA, cn[pos:length(cn)])
      nrn <- c(rn[1:(pos-1)], NA, rn[pos:length(rn)])
    }
    colnames(m2) <- ncn
    rownames(m2) <- nrn
  }
  
  return(m2)
}

collegend <- function(..., min=NA, max=NA, pal){
  leg <- c(max, rep(NA, length(pal) -2), min)
  legend(...,
         legend = leg,
         fill = pal,
         border = NA,
         #title.adj = 2,
         y.intersp = par("pin")[2]/length(pal)*4)
}

# beszur <- function(m, pos, val= 0){
#     m2 <- matrix(val,ncol=ncol(m)+1, nrow=nrow(m)+1)
#     cn <- colnames(m)
#     rn <- rownames(m)
#     
#     if(pos > 1){
#       m2[1:(pos-1), 1:(pos-1)] <- m[1:(pos-1), 1:(pos-1)]
#     }
#     if(pos <= ncol(m)){
#       m2[(pos+1):(ncol(m)+1),(pos+1):(ncol(m)+1)] <- m[pos:ncol(m),pos:ncol(m)]
#       if(pos > 1){
#         m2[pos:ncol(m)+1,1:(pos-1)] <- m[pos:ncol(m),1:(pos-1)]
#         m2[1:(pos-1),pos:ncol(m)+1] <- m[1:(pos-1),pos:ncol(m)]
#       }
#     }
#     
#     if( !is.null(cn) ) {
#       if(pos == 1){ # elejere
#         ncn <- c(NA, cn)
#         nrn <- c(NA, rn)
#       } else if(pos > ncol(m)){ #vegere
#         ncn <- c(cn, NA)
#         nrn <- c(rn, NA)
#       } else{ # koztes
#         ncn <- c(cn[1:(pos-1)], NA, cn[pos:length(cn)])
#         nrn <- c(rn[1:(pos-1)], NA, rn[pos:length(rn)])
#       }
#       colnames(m2) <- ncn
#       rownames(m2) <- nrn
#     }
#     
#     return(m2)
# }

type2noA <- Vectorize(function(x){
  if(x==0) return("A 0")
  if(x==-1) return("empty")
  
  m <- ceiling(log(x,2))
  acts <- c()
  
  for(i in m:0){
    if(x %/% 2^i != 0){
      acts <- c(acts, i)
      x <- x-2^i
      if(x == 0) break
    }
  }
  return( paste("A",length(acts)) )

})

type2A <- Vectorize(function(x){
  if(x==0) return(0)
  if(x==-1) return(NA)
  
  m <- ceiling(log(x,2))
  acts <- c()
  
  for(i in m:0){
    if(x %/% 2^i != 0){
      acts <- c(acts, i)
      x <- x-2^i
      if(x == 0) break
    }
  }
  return( length(acts) )

})


get_remote <- function(address, 
                        path="data/programs/mcrs_chromosome/OUT", 
                        path2="", 
                        key= "~/.ssh/id_rsa",
                        what="all",
                        fullpath=F    
                       ){
  if(!what %in% c("all", "dirs", "files")){
    return(-2)
  }
  
  try({
    #connect to remote host
    if(class(address) == "ssh_session"){
      con = address
      dest = F
    } else {
      con <- ssh_connect(address, keyfile = key)
      dest = T
    }
    
    
    #get data
    if(!ssh_session_info(con)$connected){
      return(-1)
    }
    if(what == "all") {
        out <- ssh_exec_internal(con, command=paste("cd", paste0(path, path2), "\nls -p"))
    } else if(what=="dirs"){
        out <- ssh_exec_internal(con, command=paste("cd", paste0(path, path2), "\nls -d */"))
    } else {
        out <- ssh_exec_internal(con, command=paste("cd", paste0(path, path2), "\nls -p | grep -v /"))
    }
    
    #disconnect
    if(dest) ssh_disconnect(con)
    
    #return data
    if(fullpath){
      return( paste( 
        paste0(path, path2), 
        ( rawToChar(out$stdout) |> strsplit("\\n") )[[1]], 
        sep="/")
      )
    } else {
      return(( rawToChar(out$stdout) |> strsplit("\\n") )[[1]])
    }
  })
  
  return(-3)
}

get_remote_dirs <- function(address, ...) get_remote(address=address, what = "dirs", ...)

get_remote_files <- function(address, pattern=NA, ...) {
  out <- get_remote(address=address, what = "files", ...)
  if(is.na(pattern)) {
    return(out)
  }
  return( grep(pattern, out, value = T) )
}

```



```{r read_data_parameters, message=FALSE, cache= !as.logical(params$ssh), cache.extra = tools::md5sum(paste0(workdir, "SAVE/parameters.txt"))}
######################
#### read in data ####
######################
if(!as.logical(params$ssh)) { #local files
  # read in simulation name from param
  #splitted <- unlist(strsplit(params$input, "/"))
  #whattosee <- splitted[length(splitted)-1]
  
  #workdir <- paste0(paste(splitted[1:(length(splitted)-1)], collapse ="/"), "/")
  #whattosee <- "test5.5"
  #whattosee <- "t3sz2_dusit95L30_1"
  
  #knitr::opts_knit$set(root.dir = workdir)
  #setwd(workdir)
  
  if(!file.exists(paste0(workdir, "SAVE/parameters.txt"))) warning("parameters file does not exist\n")
  t <- readLines(paste0(workdir, "SAVE/parameters.txt"))
  t <- read.table( text = sub(" ", "\t", t), header=F, sep="\t")
  p <- as.list(as.character(t$V2))
  names(p) <- t$V1
  
  #strsplit(readLines( paste0(workdir, "SAVE/parameters.txt") ), " ")
} else { #remote files
  library(ssh)
 
  try({ 
    #connecting to ssh
    ssh_con <- ssh_connect(params$ssh_address, keyfile = params$ssh_key)
    
    #download
    tdir = tempdir()
    scp_download(ssh_con, files= paste0(workdir, "SAVE/parameters.txt"), to=tdir)
    
    #process
    if(!file.exists(paste0(tdir, "/parameters.txt"))) 
      warning("parameters file does not exist\n")
    t <- readLines(paste0(tdir, "/parameters.txt"))
    t <- read.table( text = sub(" ", "\t", t) , header=F, sep=" ")
    p <- as.list(as.character(t$V2))
    names(p) <- t$V1
    
    #delete temp file
    file.remove(paste0(tdir, "/parameters.txt"))
  })
  
  if( !exists("ssh_con") ){
    warning("Could not establish ssh connection!\n")
    knitr::knit_exit()
  }
}

```


```{r read_data_output, message=FALSE, cache=!as.logical(params$ssh), cache.extra = tools::md5sum(paste0(workdir, "SAVE/output.txt"))}

if(!as.logical(params$ssh)) { #local files
  table <- read.table(paste0(workdir, "output.csv"), header=T, sep=";")
} else{
  try({ 
    #download
    scp_download(ssh_con, files= paste0(workdir, "output.csv"), to=tdir)
    
    #process
    if(!file.exists(paste0(tdir, "/output.csv"))) 
      warning("output file does not exist\n")
    table <- read.table(paste0(tdir, "/output.csv"), header=T, sep=";")
    
    #delete temp file
    file.remove(paste0(workdir, "output.csv"))
    
    message("output read\n")
  })
}

#str(table)

# oszlopok:
# 	time
#		replicators: number of replicators on the grid
#		no/mean_R/mean_length/mean_mfe: number/average properties of replicators having a given enzymatic activity. Note, that in case a replicator have more activities, its values are considered in more than one category.
# 	no_Ax: number of replicators having x activities
```


```{r read_data_savetimes, message=FALSE}
# read in unique data

#create state if needed
if(!"state" %in% ls()){
  state <- list()
}

#read in times
if(!as.logical(params$ssh)) { #local files
  state[["times"]] <- unlist(strsplit(
                                      list.files(paste0(workdir,"SAVE"), "*.tsv"),
                                      ".", 
                                      fixed=T))
} else {
  try({
    state[["times"]] <- unlist(strsplit(
                                        get_remote_files(ssh_con,
                                                         path=paste0(workdir,"SAVE"),
                                                         pattern="*.tsv"
                                                         ),
                                        ".", 
                                        fixed=T))
  })
  if( is.null(state[["times"]]) ){
    warning("ssh connection failed\n")
    knitr::knit_exit()
  }
}

#edit times
state$times <- state$times[seq(1, length(state$times), 2)]
state$times <- state$times[order(as.numeric(state$times))]

#set ttt
if( as.numeric(params$abrmax) < 0 ){
  ttt <- state$times
} else {
  ttt <- state$times[as.numeric(state$times) <= as.numeric(params$abrmax) & as.numeric(state$times) >= as.numeric(params$abrmin) ]
}
if(length(ttt) > 200 ){
  ttt <- ttt[round(seq(1,length(ttt), length.out=200))]
}


read_in_ttt <- ttt[!paste0("t", ttt) %in% names(state)]

```


```{r read_data_save, message=FALSE, cache=!as.logical(params$ssh), cache.lazy=F, cache.rebuild = length(read_in_ttt ) > 0, cache.extra = tools::md5sum(paste0(workdir, "SAVE/output.txt"))}
#ttt <- 0

for(tt in ttt )
{ 
  #tt=0
  #read in file
  if(!as.logical(params$ssh)) { #local files
    state[[paste0("t", tt)]] <- read.table( paste0(workdir, "SAVE/", tt, ".tsv"),
                                            sep="\t", 
                                            header=F )
  } else {
    try({
      #download
      scp_download(ssh_con, paste0(workdir, "SAVE/", tt, ".tsv"), to=tdir)
      if(!file.exists(paste0(tdir, "/", tt, ".tsv"))){ 
        warning("output file does not exist\n")
        knitr::knit_exit()
      }
      
      #process
      state[[paste0("t", tt)]] <- read.table( paste0(tdir, "/", tt, ".tsv"),
                                            sep="\t", 
                                            header=F )
      
      #delete
      file.remove(paste0(tdir, "/", tt, ".tsv"))
    })
    if( !paste0("t", tt) %in%  names(state)){
      warning("ssh connection failed\n")
      knitr::knit_exit()
    }
  }

  
  
  
  #modify column names
  if(ncol(state[[paste0("t", tt)]]) == 9 + as.numeric(p$par_noEA)){
    colnames(state[[paste0("t", tt)]]) <- c("seq", 
                                            "str", 
                                            "mfe", 
                                            "Pfold", 
                                            "Pdeg", 
                                            "no_sites",
                                            "R",
                                            "M",
                                            "type",
                                            paste0("a", 0:(as.numeric(p$par_noEA)-1)) )
  } else {
    colnames(state[[paste0("t", tt)]]) <- c("seq", 
                                            "str", 
                                            "mfe", 
                                            "Pfold", 
                                            "Pdeg", 
                                            "no_sites",
                                            "R",
                                            "M",
                                            "type",
                                            paste0("a", 0:(as.numeric(p$par_noEA)-1)),
                                            "type_prev")
  }
  
  state[[paste0("t", tt)]] <- cbind(state[[paste0("t", tt)]], type_f = as.factor(state[[paste0("t", tt)]]$type))
  state[[paste0("t", tt)]] <- cbind(state[[paste0("t", tt)]], 
                                    type_name = as.factor(as.character(enzN(state[[paste0("t", tt)]]$type))))
  
  message(paste("reading in snapshot", tt, "max:", max(as.numeric(ttt)), "number of snapshots:", length(ttt)))
  #as.character(enzN(st$type))
  #str(state)
  #state <- read.table("SAVE/1000000.tsv", sep="\t", header=F )
  #colnames(state) <- c("seq", "str", "mfe", "Pfold", "Pdeg", "no_sites", "R", "M", "type", "a0", "a1", "a2")
  #state <- cbind(state, type_f = as.factor(state$type))
}

#close ssh 
try( if(as.logical(params$ssh)) ssh_disconnect(ssh_con) )

```

# simulation properties

Simulation ID: **`r whattosee`**

Parameters:

```{r output_paramtable, cache=T, dependson="read_data_parameters"}
knitr::kable(unlist(p))
```

To see the meaning of parameters [here](#params_vis).

# simple plots from output

## number of promiscous replicators

```{r time_A, cache=TRUE, dependson="read_data_output"}
linecolors <- brewer.pal(4, "Set1")
plot(table$time, table$no_A0
     , type="l"
     , ylim=c(0, max(table$replicators))
     , main="Number of promiscous replicators"
     , col=linecolors[1])
for(i in 1:3) lines(table$time, table[,paste0("no_A", i)], col=linecolors[i+1])
legend("topleft", fill=linecolors, legend=paste("A",0:3))
```

## by activity by property

```{r time_everything, cache=TRUE, dependson="read_data_output"}
par(mfrow=c(1+as.numeric(p$par_noEA),5), oma=c(5,2,4,1), mar=c(0,4.1,0,0))

plotprop=T
axt="n"
size = as.numeric(p$par_ncol) * as.numeric(p$par_nrow)
for(ea in c(paste0("enz",0:(as.numeric(p$par_noEA)-1) ),"par" )) {
  plottype=T
  if(ea=="par") axt="s"
  for(prop in c("no", "mean_R", "mean_length", "mean_mfe", "mean_a")){
    what <- paste(prop, ea, sep="_")
    
    if(prop == "no") {
      table[,what] <- table[,what] / size
      yl = c(0,1)
    }
    else{
      yl=NULL
    }
    
    if(what == "mean_a_par") plot.new()
    else plot(table$time, table[,what], type="l", ylab="", xlab="", xaxt=axt, las=1, ylim=yl, col="red")
    
    if(plottype){
      plottype=F
      mtext(ea, 2,4)
    }
    
    if(plotprop) mtext(prop, 3,2)
  }
  if(plotprop) plotprop=F
}
mtext("time", 1, 3, outer=T)

par(par.orig) #restore default parameters

```

## frequency of promiscous replicators in the inic pool

```{r inicpool_freq_promisc, cache=T, dependson="read_data_output"}
barplot( as.numeric(table[table$time==0,paste0("no_A", 0:3)]),  
         names.arg = paste0("no_A", 0:3),
         main=paste("time:", tt, "res:", whattosee)
         )
```

## number of activities in inic pool    
```{r inicpool_no_acts, cache=TRUE, dependson="read_data_output"}
needed_cols <- c("no_par", paste0("no_enz", 0:2))
barplot( as.numeric(table[table$time==0, needed_cols])*as.numeric(p$par_ncol)*as.numeric(p$par_nrow) ,  
         names.arg = needed_cols,
         main=paste("time:", tt, "res:", whattosee)
         )
```

```{r inic_types, cache=TRUE, dependson="read_data_output"}

if(as.numeric(p$par_noEA) <= 3) {
  typecolors <- c("black", brewer.pal(2^as.numeric(p$par_noEA),"Set3"))
} else {
  #typecolors <- c("black", distinctColorPalette(2^as.numeric(p$par_noEA), altCol=TRUE, runTsne=TRUE))
  typecolors <- c("black", createPalette(2^as.numeric(p$par_noEA), c("#010101", "#ff0000"), M=100000) )
}

names(typecolors) <- c("empty", enzN(0:(2^as.numeric(p$par_noEA)-1) ))

if("0" %in% ttt){
outtable <-table(state$t0[state$t0$seq != "N", "type_name"])
  barplot(outtable, 
          names.arg = sapply(names(outtable), function(x) parse(text=x)), 
          col=sapply(names(outtable), function(x, cols) cols[x==names(cols)], typecolors) )
}
```



# unique data

```{r , fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=0.5, aniopts="controls,loop", cache=TRUE, dependson="read_data_save"}
par(mfrow=c(1,2), oma=c(0,0,2,0))
for(tt in ttt )
{ 
  #tt=0
  st <- state[[paste0("t", tt)]] # get the state
  types <- levels(st$type_f)
  
  #### PLOTS ####
  
  # histogram of mfe
  try({
    hist(st[st$type > 0,"mfe"], 
         #main = paste("time:", tt, "res:", whattosee) , 
         main = "" , 
         xlim=c(0, -35),
         ylim=c(0, as.numeric(p$par_ncol) * as.numeric(p$par_nrow)/15 )
         )
    hist(st[st$type > 0,"M"], 
         #main = paste("time:", tt, "res:", whattosee) 
         main = "",
         xlim=c(0, 2000), 
         ylim=c(0, as.numeric(p$par_ncol) * as.numeric(p$par_nrow)/15 )
         )
    
    mtext(paste("time:", tt, "res:", whattosee), outer=T)
  })
  
}
```


## MFE

```{r hist_mfegg, fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=0.5, aniopts="controls,loop", warning=F, cache=TRUE, dependson="read_data_save"}
for(tt in ttt )
{ 
  #tt=0
  st <- state[[paste0("t", tt)]] # get the state
  types <- levels(st$type_f)

  st$mfe[st$mfe < -25] <- -25 # set the minimum of mfe (it is done in runtime, anyway)
  
  print(
      ggplot(data=st[st$seq != "N",],aes(mfe, fill=type_name)) +
        geom_histogram(binwidth=0.5) +
        xlim(0,as.numeric(p$par_Emin)-2) +
        ylim(0, as.numeric(p$par_ncol)*as.numeric(p$par_nrow)/3)+
        labs(caption=paste("time:", tt, "res:", whattosee)) +
        scale_fill_discrete(labels=parse_format(), name="")
   )
}
```

## Pdeg

```{r hist_Pdeg, fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=0.5, aniopts="controls,loop", warning=F, cache=TRUE, dependson="read_data_save"}
for(tt in ttt )
{ 
  #tt=0
  st <- state[[paste0("t", tt)]] # get the state
  types <- levels(st$type_f)

  print(
      ggplot(data=st[st$seq != "N",],aes(Pdeg, fill=type_name)) +
        geom_histogram(binwidth=0.01) +
        labs(caption=paste("time:", tt, "res:", whattosee)) +
        scale_fill_discrete(labels=parse_format())+
        xlim(0,1)
      )
}
```

## Maps

```{r maps, fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=1, aniopts="controls,loop", fig.height=4.5, fig.width=7, cache=TRUE, dependson="read_data_save"}
for(tt in ttt )
{ 
  #tt=0
  par(mfrow=c(2,4), mar=c(0.5,0.5,0.5,0.5), xpd=NA, oma=c(3,0,4,0))
  plot.new()

  st <- state[[paste0("t", tt)]] # get the state
  types <- levels(st$type_f)
  
  try({
    
    #legend 1
    par(mfg=c(1,1))
    plot.new()
    u <- par("usr")
    collegend(u[2], u[4]- (u[4]-u[3])*0.15, xjust=1,
              #title="Metabolism",
              min=0, max="max", 
              bty="n",
              pal=heat.colors(300))
    text(u[2], u[4]- (u[4]-u[3])*0.1, "Metabolism", cex=1.5, adj=c(1,0))

    #map1
    par(mfg=c(1,2))
    image(1:300, 1:300, matrix(st$M, ncol=300), 
          asp=1, 
          axes=F, xlab="", ylab=""#,
          #main="Metabolism", 
          #sub=paste("time:", tt, "res:", whattosee)
          )
    
    #legend 2
    par(mfg=c(1,4))
    #plot(0,0,axes=F, pch=NA, xlab="", ylab="", main="Replication rate", adj=0)
    plot.new()
    u <- par("usr")
    collegend(u[1], u[4]- (u[4]-u[3])*0.15, 
              #title="Replication rate",
              #title.adj = 5,
              min=0, max="max", 
              bty="n",
              pal=hcl.colors(300, "PuRd"))
    text(u[1], u[4]- (u[4]-u[3])*0.1, "Replication rate", cex=1.5, adj=c(0,0))
    
    #map 2
    par(mfg=c(1,3))
    image(1:300, 1:300,matrix(st$R, ncol=300), 
          asp=1, 
          col=hcl.colors(300, "PuRd"),
          axes=F, xlab="", ylab=""#,
          #main="R", 
          #sub=paste("time:", tt, "res:", whattosee)
          )
    #mtext("Replication rate", side=3, cex=0.5, outer=F)

    #legend 3
    par(mfg=c(2,1))
    dd<- st$type
    dd[st$seq=="N"]<- -1
    u_dd <- sort(unique(dd))
    u_cols <- sapply( as.character(enzN(u_dd)), function(x, cols) cols[x==names(cols)], typecolors)
    
    plot.new()
    legend(u[2], u[4]- (u[4]-u[3])*0.15, xjust=1,
           horiz=F, 
           #legend=enzN(u_dd), 
           legend= parse(text=names(typecolors)), 
           #title="Replicator types",
           #fill=u_cols,
           fill=typecolors,
           ncol=ceiling((2^as.numeric(p$par_noEA)+1) / 10),
           bty="n")
    text(u[2], u[4]- (u[4]-u[3])*0.1, "Replicator types", cex=1.5, adj=c(1,0))
    
    #map 3
    par(mfg=c(2,2))
    image(1:300, 1:300, matrix(dd, ncol=300), 
          col= u_cols , 
          asp=1, #main="Replicator types",
          axes=F, xlab="", ylab="")
    
    #legend 4
    par(mfg=c(2,4))
    
    plot.new()
    u<-par("usr")
    u_dd <- -1:as.numeric(p$par_noEA) 
    u_dd[u_dd > -1] <- paste("A", u_dd[u_dd > -1])
    u_dd[u_dd=="-1"] <- "empty"
    legend(u[1], u[4]- (u[4]-u[3])*0.15,
           horiz=F, 
           #legend=c("empty", "parasite", "specialist", "2act", "3act"), 
           legend= u_dd, 
           #title="Promiscuity level",
           fill=c("black", brewer.pal(length(u_dd)-1,"Dark2")),bty="n" )
    text(u[1], u[4]- (u[4]-u[3])*0.1, "Promiscuity level", cex=1.5, adj=c(0,0))

    #map 4
    par(mfg=c(2,3))
    # dd[dd %in% c(1,2,4)]<- 1
    # dd[dd %in% c(3, 5,6)]<- 2
    # dd[dd == 7]<- 3
    # #u_dd <- sort(unique(dd))
    dd<- st$type
    dd[st$seq=="N"]<- -1    
    #dd <- type2noA(dd)
    image(1:300, 1:300, matrix(dd, ncol=300), 
          col= c("black", brewer.pal(length(u_dd)-1,"Dark2")) , 
          asp=1, #main="Promiscuity level",
          axes=F, xlab="", ylab="")
    
    #titles
    mtext(tt, outer = T, cex=2, line=1)
    mtext(whattosee, line=1, outer = T, side=1)
  })

}
```

## Properties of types

```{r propsbars, eval=F, fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=1, aniopts="controls,loop", cache=TRUE, dependson="read_data_save"}
for(tt in ttt )
{ 
  # select data
  st <- state[[paste0("t", tt)]] # get the state
  st <-st[st$seq!="N",]
  st$length <- nchar(st$seq)
  
  #plot
  pppp <- lapply(unique(st$type), function(x, st) stack(st[st$type==x, ], select=c("mfe", "length", "R"), drop=F), st)
  names(pppp)= unique(st$type)
  
  stlong <- data.frame()
  for( typeit in sort(unique(st$type)) ){
    stlong <- rbind(stlong, 
                    cbind(  pppp[[ as.character(typeit) ]], 
                            type=rep( as.character(enzN(typeit)), nrow(pppp[[ as.character(typeit) ]]) ) 
                          )
                    )
  }
  stlong$type <- as.factor(stlong$type)
  
  try(print({
  ggplot(data=stlong, aes(x=type, fill=ind)) +
    geom_bar(aes(y=values), stat="summary", fun="mean", position=position_dodge()) +
    scale_x_discrete(labels=parse( text= levels(stlong$type) ))+
    labs(title=tt, caption=whattosee)
  }))
}
```



```{r propsall, eval=T, fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=1, aniopts="controls,loop", warning=FALSE, fig.height=12, fig.width=8, cache=TRUE, dependson="read_data_save"}

drop_unused = F
dropfrom = 3

for(tt in ttt )
{ 
  # select data
  st <- state[[paste0("t", tt)]] # get the state
  st <- st[st$seq != "N",]

  if(nrow(st) == 0) {
    pic <- matrix(c(0,1,0,0,0,0,0,0,0,0,0,1,0,
                    1,1,0,0,0,0,0,0,0,0,0,1,1,
                    0,0,0,1,1,1,1,1,1,1,0,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,1,1,0,0,1,0,0,1,1,0,0,
                    0,0,1,1,1,1,1,1,1,1,1,0,0,
                    0,0,0,1,1,1,1,1,1,1,0,0,0,
                    1,1,0,1,1,0,1,0,1,1,0,1,1,
                    0,1,0,0,0,0,0,0,0,0,0,1,0
            ), ncol=9)
    image(1:nrow(pic), 1:ncol(pic), pic, ylim=c(nrow(pic),0.5), asp=1, axes=F, xlab="", ylab="")
    next
  }
  st$length <- nchar(st$seq)
  
  kell <- 0:(2^as.numeric(p$par_noEA)-1)
  
  #reorder by numbers of activities
  kell2 <- kell[order(type2noA(kell))]

  pppp <- lapply(unique(st$type), function(x, st) {
    out <- stack(st[st$type==x, ], select=c("mfe", "Pfold", "length", "R", "Pdeg"), drop=F)
    out <- rbind(out, data.frame(values=sum(st$type==x), ind="count") )
    return(out)
  }
  , st)
  
  names(pppp)= unique(st$type)
  
  stlong <- data.frame(values=numeric(), ind=factor(levels=levels(pppp[[1]]$ind )), type=factor(levels=enzN(kell2)))
  for( typeit in sort(unique(st$type)) ){
    stlong <- rbind(stlong, 
                    cbind(  pppp[[ as.character(typeit) ]], 
                            type=rep( as.character(enzN(typeit)), nrow(pppp[[ as.character(typeit) ]]) ) 
                    )
    )
  }
  stlong$type <- factor(stlong$type, levels = enzN(kell2))
  stlong$type <- factor(stlong$type, levels = enzN(kell2[type2A(kell2) < dropfrom | table(stlong$type) > 0]) ) #drop unused levels over dropfrom

  #transformations
  #stlong[stlong$ind == "count", "values"] <- stlong[stlong$ind == "count", "values"]/as.numeric(p$par_ncol)/as.numeric(p$par_nrow) #proprtional to number of cells
  #stlong[stlong$ind == "count", "values"] <- stlong[stlong$ind == "count", "values"]/ sum(stlong[stlong$ind == "count", "values"])
  #stlong[stlong$ind == "mfe", "values"] <- stlong[stlong$ind == "mfe", "values"] / 25
  #stlong[stlong$ind == "length", "values"] <- stlong[stlong$ind == "length", "values"] / as.numeric(p$MAXLEN)
  
  Rmax <- as.numeric(p$par_g) / ( as.numeric(p$par_b1)+as.numeric(p$par_b2) ) * ( as.numeric(p$par_ll) )
  #stlong[stlong$ind == "R", "values"] <- stlong[stlong$ind == "R", "values"] / Rmax

  if(nrow(stlong) >0){
    gplots <- list(
      #mfe
      ggplot(data=stlong[stlong$ind == "mfe", ], aes(x=type, fill=type, y=values)) +
        facet_grid(ind~.)+
        #geom_boxplot(aes(y=values))+
        geom_violin(width=1)+
        stat_summary(fun=mean, geom="point")+
        scale_x_discrete(labels=parse( text= levels(stlong$type) ), drop=drop_unused)+
        coord_cartesian(ylim = c(0, -30))+
        labs(title= tt, subtitle=whattosee)+
        theme(axis.title.x = element_blank(), 
              axis.text.x=element_blank(),
              axis.ticks = element_blank(),
              legend.position = "none",
              axis.title.y = element_blank()),
      
      
      #Pfold
      ggplot(data=stlong[stlong$ind == "Pfold", ], aes(x=type, fill=type, y=values)) +
        facet_grid(ind~.)+
        geom_violin(width=1)+
        stat_summary(fun=mean, geom="point")+
        #geom_boxplot(aes(y=values))+
        scale_x_discrete(labels=parse( text= levels(stlong$type) ), drop=drop_unused)+
        scale_y_continuous(breaks= c(0, 1), 
                           labels= c("0%", "100%"), 
                           #limits = c(0,1),
                           #sec.axis = sec_axis(~ . * 1.20, name = "mpg (UK)")
                           ) +
        coord_cartesian(ylim = c(0, 1))+
        theme(axis.title.x = element_blank(), 
              axis.text.x=element_blank(),
              axis.ticks = element_blank(),
              legend.position = "none",
              axis.title.y = element_blank()),
      
      
      #Pdeg
      ggplot(data=stlong[stlong$ind == "Pdeg", ], aes(x=type, fill=type, y=values)) +
        facet_grid(ind~.)+
        geom_violin(width=1)+
        stat_summary(fun=mean, geom="point")+
        #geom_boxplot(aes(y=values))+
        scale_x_discrete(labels=parse( text= levels(stlong$type) ), drop=drop_unused)+
        scale_y_continuous(breaks= c(0, 1), 
                           labels= c("0%", "100%"), 
                           #limits = c(0,1),
                           #sec.axis = sec_axis(~ . * 1.20, name = "mpg (UK)")
                           ) +
        coord_cartesian(ylim = c(0, 1))+
        theme(axis.title.x = element_blank(), 
              axis.text.x=element_blank(),
              axis.ticks = element_blank(),
              legend.position = "none",
              axis.title.y = element_blank()),
    
      
      #R
      ggplot(data=stlong[stlong$ind == "R", ], aes(x=type, fill=type, y=values)) +
        facet_grid(ind~.)+
        #geom_boxplot(aes(y=values))+
        geom_violin(width=1)+
        stat_summary(fun=mean, geom="point")+
        scale_x_discrete(labels=parse( text= levels(stlong$type) ), drop=drop_unused)+
        scale_y_continuous(#breaks= c(0, 1), 
                           labels= function(x) paste(round(x,2)), 
                           #limits = c(0,Rmax),
                           #limits = c(0,max(stlong[stlong$ind == "R", "values"])),
                           #sec.axis = sec_axis(~ . * 25, name = "kJ", breaks=-25:0)
                           )  +
        #coord_cartesian(ylim = c(-30, 0))+
        theme(axis.title.x = element_blank(), 
              axis.text.x=element_blank(),
              axis.ticks = element_blank(),
              legend.position = "none",
              axis.title.y = element_blank()),
  
      
      #length
      ggplot(data=stlong[stlong$ind == "length", ], aes(x=type, fill=type, y=values)) +
        facet_grid(ind~.)+
        geom_violin(width=1)+
        stat_summary(fun=mean, geom="point")+
        #geom_boxplot(aes(y=values))+
        scale_x_discrete(labels=parse( text= levels(stlong$type) ), drop=drop_unused)+
        scale_y_continuous(#breaks= c(0, 1), 
                           #labels= c("0%", "1%"), 
                           #limits = c(0,as.numeric(p$MAXLEN)/3),
                           #sec.axis = sec_axis(~ . * 25, name = "kJ", breaks=-25:0)
                           )  +
        coord_cartesian(ylim = c(0, as.numeric(p$MAXLEN)/3))+
        theme(axis.title.x = element_blank(), 
              axis.text.x=element_blank(),
              axis.ticks = element_blank(),
              legend.position = "none",
              axis.title.y = element_blank()),
      #count
      ggplot(data=stlong[stlong$ind=="count",], aes(x=type, 
                                                    fill=type,
                                                     #y=values / as.numeric(p$par_ncol) / as.numeric(p$par_nrow)
                                                     y=values / sum(stlong[stlong$ind=="count", "values"])
                                                    )) +
        facet_grid(ind~.)+
        geom_bar(stat="identity") +
        geom_text(aes(label=values), 
                  position = position_stack(vjust=0.5),
                  size=2, 
                  fill=NA, 
                  angle=270)+
        scale_x_discrete(labels = parse_format(), drop=drop_unused )+
        scale_y_continuous(breaks= c(0, 1), 
                           labels= c("0%", "100%"))+
        coord_cartesian(ylim = c(0, 1), clip="off" )+
        theme(legend.position = "none",
              axis.ticks = element_blank(),
              axis.title.y = element_blank())
    )
    
    
    print(plot_grid( plotlist= gplots, align = "v", ncol = 1, rel_heights = c(1.5,1,1,1,1,2) ))
  }
}

```



























# Diagnostics

```{r eval=F}
max(table$time)
table[table$time == max(table$time),]



#Pfold
ggplot(data=state[state$seq != "N",],aes(Pfold, fill=type_f)) +
  geom_histogram() 
ggplot(data=state0[state0$seq != "N",],aes(Pfold, fill=type_f)) +
  geom_histogram() 
curve(1- 1/(1+ exp( -0.3*x )), xlab="mfe", xlim=c(-25,0), ylab="Pfold")

#mfe
ggplot(data=state[state$seq != "N",],aes(mfe, fill=type_f)) +
  geom_histogram(binwidth=0.5) 
xlim(0,as.numeric(p$par_Emin))
plot(table$time, table$mean_mfe_par
     , type="l"
     , ylim=c(-25,0)
     , main="Number of promiscous replicators"
     , col=linecolors[1])
for(i in 0:2) lines(table$time, table[,paste0("mean_mfe_enz", i)], col=linecolors[i+1])
legend("topleft", fill=linecolors, legend=paste("A",0:3))

#Pdeg
ggplot(data=state[state$seq != "N",],aes(Pdeg, fill=type_f)) +
  geom_histogram() 
mfe=-0.00001
0.9-0.8*mfe/-25
curve(0.9-0.8*x/-25, xlim=c(-25,0))

#a
curve(x*1* 1/(1^1.1), xlab="Pfold", ylab="a", xlim=c(0,1))
curve(  ( 1- 1/(1+ exp( -0.3*x )) )  *1* 1/(1^1.1), xlab="mfe", ylab="a", xlim=c(-25,0))

#R
ggplot(data=state[state$seq != "N",],aes(R, fill=type_f)) +
  geom_histogram() 
ggplot(data=state0[state0$seq != "N",],aes(R, fill=type_f)) +
  geom_histogram() 

curve(    10/ (0.75 + 0.005 * 30) * ( 2 - x)   , xlab="Pfold", ylab="R", )
curve(    10/ (0.75 + 0.005 * 30) * ( 2 - ( 1- 1/(1+ exp( -0.3*x )) ) )   , xlab="mfe", ylab="R", xlim=c(-25,0))


# a*a*a*R

curve( (( 1- 1/(1+ exp( -0.3*x )) )  *1* 1/(1^1.1))^3  *  10/ (0.75 + 0.005 * 30) * ( 2 - ( 1- 1/(1+ exp( -0.3*x )) ) )   , xlab="mfe", ylab="R*a*a*a", xlim=c(-25,0))

#a*R
curve( (( 1- 1/(1+ exp( -0.3*x )) )  *1* 1/(1^1.1))  *  10/ (0.75 + 0.005 * 30) * ( 2 - ( 1- 1/(1+ exp( -0.3*x )) ) )   , xlab="mfe", ylab="R*a", xlim=c(-25,0))


```


















# komplementer plot

```{r kompl, eval=as.logical(params$kompl), fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=0.5, aniopts="controls,loop", cache=TRUE, dependson="read_data_save"}

try({
  for(tt in ttt ){
    st <- state[[paste0("t", tt)]] # get the state
    types <- levels(st$type_f)
    
    # Read in reverse state
    #cout <- system("../../rev 300 300 3 ../../IN/mapping.txt SAVE/0.tsv", intern=T)
    cout <- system(paste("../rev",  
                         p$par_nrow, 
                         p$par_ncol,
                         p$par_noEA, 
                         paste0("../", p$par_str_pool), 
                         paste0(workdir, "SAVE/", tt, ".tsv"))
                   , intern=T)
    rev_state <- do.call(rbind.data.frame, strsplit(cout, "\t"))
    colnames(rev_state) <- c("seq", 
                              "str", 
                              "mfe", 
                              "Pfold", 
                              "Pdeg", 
                              "no_sites", 
                              "R", 
                              "type", 
                              paste0("a",0:(as.numeric(p$par_noEA) -1) ) )
    
    # calculate table
    van <- st$seq != "N"
    odf <- data.frame(orig=st$type[van], rev=rev_state$type[van])
    odf$orig <- factor(odf$orig, levels = 0:(2^as.numeric(p$par_noEA)-1))
    odf$rev <- factor(odf$rev, levels = 0:(2^as.numeric(p$par_noEA)-1))
    pairs <- table(odf)
    
    #make it square
    # pairs2 <- data.frame()
    # for(i in 0:5) {
    #   if( !i %in% as.numeric(colnames(pairs)) ){
    #     if(i>0) pairs2 <- cbind(pairs2, pairs[,1:i])
    #     pairs2 <- cbind(pairs2, rep(0, nrow(pairs)) )
    #     if( (i+1) <5) pairs2 <- cbind(pairs2, pairs[ (i+1):ncol(pairs) ] )
    #   } 
    # }
    
    
    # p2 <- pairs
    # p2[lower.tri(pairs)] <- p2[lower.tri(pairs)] + t(p2)[lower.tri(pairs)] # add to each other
    # p2[upper.tri(pairs)] <- t(p2)[upper.tri(pairs)] # make it symmetric
    pairs <- pairs + t(pairs)
    diag(pairs) <- diag(pairs)/2
    
    tv <- as.numeric(colnames(pairs))
    kell <- 0:(2^as.numeric(p$par_noEA)-1)
    
    
    
    pairs2 <- pairs
    for( ke in kell[!kell %in% tv]+1 ) pairs2 <- beszur(pairs2, ke)
    colnames(pairs2) <- kell
    rownames(pairs2) <- kell
    
    #komplementer plot for state
    
    image(kell, kell,  pairs2, 
          xaxt="n", yaxt="n" ,
          xlab="", ylab="",
          main = tt, sub= whattosee
          )
    axis(1, at= kell, labels=enzN(kell))
    axis(2, at= kell, labels=enzN(kell), las=1)
    abline(h= kell+0.5)
    abline(v= kell+0.5)
  }
})

```

```{r kompl_easy, eval= !as.logical(params$kompl), fig.show='animate', animation.hook="ffmpeg", ffmpeg.format="mp4", interval=0.5, aniopts="controls,loop", fig.height=12, fig.width=8, cache=TRUE, dependson="read_data_save"}

cat("WARNING: these are based on ancestry, not on actual reversing")

for(tt in ttt ){
  try({
    par(mfrow=c(2,1))
  
    st <- state[[paste0("t", tt)]] # get the state
    types <- levels(st$type_f)
    
    # calculate table
    van <- st$seq != "N"
    odf <- data.frame(orig=st$type[van], rev=st$type_prev[van])
    odf$orig <- factor(odf$orig, levels = 0:(2^as.numeric(p$par_noEA)-1))
    odf$rev <- factor(odf$rev, levels = 0:(2^as.numeric(p$par_noEA)-1))
    pairs <- table(odf)
    
    #make it square
    # pairs2 <- data.frame()
    # for(i in 0:5) {
    #   if( !i %in% as.numeric(colnames(pairs)) ){
    #     if(i>0) pairs2 <- cbind(pairs2, pairs[,1:i])
    #     pairs2 <- cbind(pairs2, rep(0, nrow(pairs)) )
    #     if( (i+1) <5) pairs2 <- cbind(pairs2, pairs[ (i+1):ncol(pairs) ] )
    #   } 
    # }
    
    
    # p2 <- pairs
    # p2[lower.tri(pairs)] <- p2[lower.tri(pairs)] + t(p2)[lower.tri(pairs)] # add to each other
    # p2[upper.tri(pairs)] <- t(p2)[upper.tri(pairs)] # make it symmetric
    pairs <- pairs + t(pairs)
    diag(pairs) <- diag(pairs)/2
    
    tv <- as.numeric(colnames(pairs))
    
    kell <- 0:(2^as.numeric(p$par_noEA)-1)
    
    pairs2 <- pairs
    for( ke in kell[!kell %in% tv]+1 ) pairs2 <- beszur(pairs2, ke)
    colnames(pairs2) <- kell
    rownames(pairs2) <- kell
    
    #reorder by numbers of activities
    kell2 <- kell[order(type2noA(kell))]
    pairs2 <- pairs2[as.character(kell2),]
    pairs2 <- pairs2[,as.character(kell2)]
    
    
    
    #komplementer plot for state
    
    image(kell, kell,  
          pairs2, 
          xaxt="n", yaxt="n" ,
          xlab="", ylab="",
          col= heat.colors(100, rev = TRUE)[5:100],
          main = tt, sub= whattosee
          )
    axis(1, at= kell, labels=enzN(kell2), las=2)
    axis(2, at= kell, labels=enzN(kell2), las=1)
    abline(h= kell+0.5)
    abline(v= kell+0.5)
    
    image(kell, kell,  
      log(pairs2+1), 
      #pairs2, 
      xaxt="n", yaxt="n" ,
      xlab="", ylab="",
      #col= hcl.colors(200, "YlOrRd", rev = TRUE),
      col= heat.colors(100, rev = TRUE)[5:100],
      main = "on a logaritmic scale"
    )
    text(rep(kell, length(kell)), rep(kell, each=length(kell)), c(pairs2), cex=0.5 )
    
    axis(1, at= kell, labels=enzN(kell2), las=2)
    axis(2, at= kell, labels=enzN(kell2), las=1)
    abline(h= kell+0.5)
    abline(v= kell+0.5)
  })
}

```



# nem tudom ez mi

```{r , eval=FALSE}
barplot(table( state[state$seq != "N", "type"] ), names.arg = enzN(0:5) )
barplot(table( rev_state[state$seq != "N", "type"] ), names.arg = enzN(0:5) )

barplot(table( state0[state0$seq != "N", "type"] ), names.arg = enzN(0:4) )
barplot(table( rev_state0[rev_state0$seq != "N", "type"] ) )

```

# Parameters visually {#params_vis}

## Neighbourhood sizes
```{r metN, cache=T, dependson="read_data_parameters"}
par(mfrow=c(1,2))

n_neighsMet <- plotNeigh(as.numeric(p$par_Nmet), main="Metabolic neighbourhood", sub=p$par_Nmet)
n_neighsRep <- plotNeigh(as.numeric(p$par_Nrep), main="Replication neighbourhood", sub=p$par_Nrep)

```

Number of cells in a metabolic neighborhood: `r n_neighsMet` and in a replication neighborhood: `r n_neighsRep` (central cell included).

## Probablity of being folded

$$P_{fold} = \frac{1}{1 + e^{-cE}}$$

```{r params_Pfold, cache=T, dependson="read_data_parameters"}
curve(1/(1+exp(as.numeric(p$par_c)*x)),
      xlim=c(0, as.numeric(p$par_Emin)-5),
      ylim=c(0,1),
      xlab="MFE",
      ylab=expression(P[fold]),
      main=p$par_ID,
      yaxt="n"
      )
axis(2, at=c(0,0.5,1), labels=c("0%", "50%", "100%"), las=1)
```

## Subadditive effect for cis-promiscous enzimatic activities 

Each motif has a basic activity ($\alpha_i$), but in case a replicator has more than one, than those activities will be counted as follows:

$$a_i=P_{fold} \frac{\alpha_i}{m^\sigma}, ~ \sigma >1$$

In case of $P_{fold} = 1$ and $\alpha_i=100\%$ for all $i$, it means:

```{r params_activities, cache=T, dependson="read_data_parameters"}

xv <- 1:10
plot(xv, 1/(xv^as.numeric(p$par_sigma)),
     ylim=c(0,1),
     xlim=c(1,10), 
     type="b",
     yaxt="n",
     xlab="number of active sites (m)",
     ylab=expression(a[i]),
     main=p$par_ID
     )
axis(2, at=c(0,0.5,1), labels=c("0%", "50%", "100%"), las=1)
```

## Rate of degradation

```{r params_Pdegvals_cont, cache=T, dependson="read_data_parameters"}
Pdegmax=ifelse("par_maxPdeg" %in% names(p), as.numeric(p$par_maxPdeg), 0.9)
Pdegrange=ifelse("par_rangePdeg" %in% names(p), as.numeric(p$par_rangePdeg), 0.8)
```


$P_{deg}=$ `r Pdegmax` - `r Pdegrange` $\frac{E}{E_{min}}, ~ E \ge E_{min}$

```{r params_Pdegvals, cache=T, dependson="params_Pdegvals_cont"}
curve(Pdegmax - Pdegrange*ifelse(x<as.numeric(p$par_Emin), as.numeric(p$par_Emin), x)/as.numeric(p$par_Emin),
      xlim=c(0, as.numeric(p$par_Emin)-5),
      ylim=c(0, 1),
      yaxt="n",
      xlab="MFE",
      ylab=expression(P[deg]),
      main=p$par_ID
      )
axis(2, at=c(0,0.5,1, Pdegmax, Pdegmax-Pdegrange), labels=c("0%", "50%", "100%", paste0(c(Pdegmax, Pdegmax-Pdegrange)*100, "%")), las=1)
grid()
```


## Replication rate


$$R_i(P_{fold}, L)=\frac{g}{b_1+b_2L} \left [ l+ (1-P_{fold})\right], ~ l > 0$$
$$R_i(P_{fold}, L)=W(L) \left( \hat l -P_{fold}\right), ~ \hat l > 1$$

```{r, params_R, cache=T, dependson="read_data_parameters"}

Pfs <- seq(0, 1, 0.1)
colPf <- brewer.pal(length(Pfs), "Paired")
  
curve(as.numeric(p$par_g) / ( as.numeric(p$par_b1) + as.numeric(p$par_b2) * x ) * ( as.numeric(p$par_ll) - Pfs[1] ) ,
      xlim=c(0,as.numeric(p$MAXLEN)),
      ylim=c(0, as.numeric(p$par_g) / ( as.numeric(p$par_b1) ) * ( as.numeric(p$par_ll))),
      ylab="R",
      xlab="length",
      las=1,
      col=colPf[1],
      main=p$par_ID
      )

for(i in 2:length(Pfs)) curve(as.numeric(p$par_g) / ( as.numeric(p$par_b1) + as.numeric(p$par_b2) * x ) * ( as.numeric(p$par_ll) - Pfs[i] ) ,
      add=T,
      col=colPf[i]
      )
legend("topright", 
       title = expression(P[fold]), 
       lwd=2, 
       col=colPf,
       legend=Pfs, 
       ncol=2)
```

## Enzimatic activities

Should make a plot where show:

  * number of activities
  * motifs: 2D structure, neccessary seqs
  * plot activities based on number of all free bases / number of free G/C

it is too much time
